## Day03
> 这一次实现了对磁盘文件的读取，将磁盘文件中各个扇区的内容读入到内存中，

#### 汇编语言
		mov	CH,0
		mov	DH,0
		mov	CL,2
		mov AH,0x02
		mov	AL,1
		mov	BX,0
		mov	DL,0x00
		INT	0x13

- JC : Jump if carry 如果进位标志为1 的话，就跳转,函数调用出错，进位标志1,函数调用无错，进位标志为0
- JNC	: Jump if not carry :如果进位标志为0,即没有出错则跳转
- JAE	: Jump if above or equal 如果大于等于就跳转
- JBE	: Jump if below	or equal 小于等于则跳转
- JB	:	Jump if below 小于则跳转
- EQU	:	程序最前面，用于声明常数，相当与C语言中的#define
- INT 0x13 : 调用BIOS的0x13号函数，根据AH中的值对磁盘进行操作
	- AH = 0X02	: 读盘
  - AH = 0x03	: 写盘
  - AH = 0x04 : 校验
  - AH = 0x0c : 寻道
  - AL = 处理对象的扇区数，
  - CH = 柱面号
  - CL = 扇区号
  - DH = 磁头号
  - DL = 驱动器号
  - ES:BX 缓冲地址，
  	- 内存地址
  	- 表示从内存中读取的数据要装载到软盘的位置，计算机开发初期（没有EBX的时期）利用这两个寄存器来增加内存空间，
  	- [ES:BX] = ES \* 16 + BX
  	- 程序如果不指定段寄存器，默认使用DS mov CX,[123] == mov CX,[DS:1234],
  	- ** 每次使用需要将 DS置为 0 **

  - FLAGS.CF == 0 没有错误
  - FLAGS.CF == 1 有错误，错误存在AH中

#### 读取下一个扇区

		ES + 0x20
		CL + 1
	
	- ES 指定读入的地址
	- 0x20 是16进制以下 512/16 的结果，也可直接使用 add AX,512/16来替换
	- 直接将AL = 17 也可读入18个扇区，但会出问题。
	- 读入18 个扇区之后，将磁盘上的前18个扇区装入内存的
	0x8200-0xa3ff处。
#### 磁盘的读取
	- CH : 柱面
	- DH : 磁头
	- CL : 扇区
	- 数据在磁盘中的读取顺序是扇区-->磁头-->柱面
#### DD 函数
		防止后面的dd 数据会覆盖前面的光盘数据，利用seek 指定开始的块
	
#### 记录
		汇编就是利用简单的指令一句句的变成，可以利用标签实现函数的循环等操作。
#### haribote.sys
	- 这个文件应该是直接利用nasm编译生成的，将该文件保存到光盘中的方法就是把光盘镜像挂载，然后将该文件
		拷贝到镜像文件中即可
	- 文件拷贝到镜像文件中后文件名在 0x2620处，文件内容在 0x4400处
	- 启动 0x4400 处的程序，程序是从内存的0x8000号地址开始装入的，那么磁盘 0x4400 则在内存的
	0x8000+0x4400 = 0xc400 处，这样就在haribote.nas 文件中加入 org 0x4400 在ipl.nas 程序的结束添加 JMP
	0xc400 即可
#### 关于启动
	在利用qemu-system-i386 启动镜像文件时一定要添加 -fda 选项,表明系统是从软盘中启动，否则就会使用默认
	的hda选项，即从硬盘中启动。
