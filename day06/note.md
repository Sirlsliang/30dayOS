## Day05

#### 关于Makefile
- make首先使用普通的生成规则，如果没有普通规则，则尝试使用一般规则。
- 当前目标文件名称: %@
- 当前所依赖的源文件的名称:$<
- 当前所依赖的源文件的名称（不带后缀名）：$*
- 当前目标所依赖的源文件列表中比当前目标文件还要新的文件：$?
- 让make命令忽略所有错误： -
- 执行某个命令前不再标准输出显示该命令： @
- 表示$@的目录部分(不以斜杠作为结尾):$(@D),如果$@中没有斜杠，其值就是"."
- 表示$@的文件部分：$(@F)
	
####  段表
- 段表的数量为：8192,第一个段表中存储着所有的内存信息，第二个段表存储着启动信息，段表的数量不一定
就是段的数量。
- 一个段表8个字节
- GDTR中存放着内存的起始地址和有效设定个数

#### GDTR寄存器
- 48位
- LGDT指令赋值，指定内存地址，从指定的地址读取6个字节，然后赋值给GDTR寄存器
- 低16位是段上限，高32位代表GDT的开始地址

#### 段描述符
- 8个字节
- 段描述符存储的内容：段的大小(limit)，段的起始地址(base)、段的管理属性（禁止写入、禁止执行、
系统专用等）
- 段描述符的结构:
		struct SEGMENT_DESCRIPTOR{
			short limit_low, base_low;
			char base_mid,	access_right;
			char limit_high, base_high;
		}
- 基址被分为了：low(2字节),mid(1Byte)和high(1Byte)三个部分,主要为了兼容
- 段上限表示段的大小，最大为4GB，能用的有20位，其中高4位用来描写段的属性，后20位
描写段的上限，为了能够充分的描述内存，将内存分页（每页4KB）,能够表示(2的20次方= 1MB),
1MB * 4KB 个页，即4GB的段。
- 段属性 12位，其中limit_high中的高4位和access_right的8位，
- 权限划分： 权限的高4位由GD00组成，G表示G bit，D：表示段的模式，1指32位，0指16
位，access_right(ar),的低8位（0x00:未使用的记录表;0x92:系统专用，可读写的段，不
可执行; 0x9a:系统专用，可执行的段，可度不可写;0xf2:应用程序用，可读写的段，不可
执行;0xfa:应用程序段，可执行的段，可读不可写）

#### 中断
- PIC(programmable interrupt controller); 可编程中断控制器。
- PIC: 将8个中断信号（IRQ:interrupt rquest）集合成一个中断信号的装置。
- PIC只有一根管线与CPU相连，PIC有8个管线接收中断，其中2号管线又连接一个从PIC，8
跟管线，只要接收到中断信号，便通过与CPU相连的唯一的管线通知CPU。
- PIC0:主PIC，PIC1:从PIC
- PIC中有多个寄存器，之间用端口号区分，
- io_sti(): 执行STI指令，CLI的逆指令，执行STI指令之后，IF变为1,CPU接受来自外部设备的中断。

#### PIC中的寄存器
- PIC中有多个寄存器，都是8位的寄存器
- IMR(interrupt mask register): 中断屏蔽寄存器,8位代表8路IRQ信号，值是1则对应的IRQ信号被屏蔽，PIC忽视该路信号。
- ICW(initial control word) :初始化控制数据，有4个，共有4字节的数据,编号为1-4。ICW1与ICW4与PIC主
板比较大的关系，ICW3有关主从连接的设定，位数对应那一路连接从PIC。ICW2决定了IRQ以哪一种中断通知CPU，
- INT 0x00~0x1f 是CPU内部自动产生的中断，因此需要从0x20开始。

#### 中断号
- 鼠标：IRQ12，12+0x20 = 0x2c
- 键盘：IRQ1		1+0x20 = 0x21

#### 中断处理
- 中断不能执行return（RET）指令，必须执行IRETD指令

#### 汇编
- PUSHAD：等于（push EAX,EBX,ECX,EDX,ESP,EBP,ESI,EDI)将所有的寄存器都push入栈。
- POPAD	：将所有的寄存器都pop出栈
- call :	调用函数
- extern	： 没有在源文件中定义的函数
