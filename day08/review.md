## Review

#### 寄存器
- 通用寄存器（16位）
	AX:累加寄存器,	AL:累加寄存器低位,	AH:累加寄存器高位
	CX:计数寄存器;	CL:计数寄存器低位，	CH:计数寄存器高位
	DX:数据寄存器; 	DL:数据寄存器低位,	DH:数据寄存器高位
	BX:基址寄存器;	BL:基址寄存器低位，	BH:基址寄存器高位
	SP:栈指针寄存器; 
	BP:基址指针寄存器; 
	SI: 源变址寄存器; 
	DI:目的变址寄存器
- 段寄存器（16位）
	ES:附加段寄存器; 
	CS:代码段寄存器; 
	SS:栈段寄存器; 
	DS:数据段寄存器;
	FS: 没有名称; 
	GS: 没有名称

#### 汇编
- 不管要指定内存的什么地址，都必须同时指定段寄存器。省略的话就会把DS作为默认的段寄存器
		mov CX, [1234] = mov CX, [DS:1234] 即 CX = DS * 16 + 1234
		mov AL,	[SI] = mov AL, [DS:AL] 即 AL = DS * 16 + AL
- 显示一个字符
		AH=0x0e
		AL=character code 
		BH=0 
		BL=color code
		INT 0x10
	根据上面的步骤，向寄存器中带入各种值，再调用INT 0x10即可在屏幕上显示值
- 读取硬盘
		CH=柱面号
		DH=磁头号
		CL=扇区
		AH=0x02读盘/AH=0x03 写盘/ AH=0x04 校验/ AH=0x0c 寻道
		AL=处理对象的扇区数（同时处理连续的扇区数）
		BX=缓冲地址(校验及寻道时不用)
		DL=驱动器号
		INT 0x13
		JC
	INT 0x13调取BIOS的13号函数，根据前面的设置对磁盘进行操作。调用INT 0x13之后，会返回一个标志位，利用
	JC来检查该标志，进位标志0,没有错误，1有错误，错误号码在AH中
- 切换显示模式
		AH=0x00
		AL=模式
		INT 0x10
	0x03:	16色字符模式; 
	0x12: VGA图形模式，640x480x4位彩色模式
	0x13: VGA图形模式，320x200x8位彩色模式，调色板模式
	0x6a:	扩展VGA图形模式，800x600x4位彩色模式
	不同的画面模式，图像缓冲区在内存中的位置都不一样，假如利用0x13这个模式,其图像缓冲区在
	内存的0xa0000~0xaffff处，对该处的内存操作便可实现画面的显示
-	ORG: 告诉编译器，将程序用到的段内偏移地址自动加上org后面跟的数值。本身并不能决定程序将要添加到内存
的什么位置，只是告诉编译器，程序在编译好后需要加载到xxx地址，在编译时要调整好数据访问时的地址。

#### 系统的启动
- 首先将启动文件拷贝到img文件中，确定文件的地址。
- 操作系统启动是，首先会读取img文件的第一个扇区即前512字节，查看该扇区最后的两个字节是否为0x55与0xAA
，如果是这两个字节则认为该img为操作系统，就从内存的0x7c00处开始加载文件。
- 从0x7c00处加载，程序跳入0x7c50处开始执行指令。加载前10个柱面即 10 × 18 × 2 × 512 = 180 KB。
- 数据加载完毕后，会跳入asmhead.nas与bootpack.c连接生成的sys文件中执行,完成系统的启动

#### 各个文件的分析
1. ipl: 启动程序加载器，BIOS完成文件检测后，便加载该程序，512字节，最后两个字节为0x55 0xAA，该文件从
内存的0x7c00处加载
2. asmhead: 操作系统的启动程序，ipl将数据加载到内存之后，便运行该文件所在的程序，在内存的0xc400处开
始加载。
3. naskfunc: 定义了无法用C语言实现的函数，在该文件中利用汇编语言实现
4. bootpack: 操作系统的主函数
5. graphic:	 定义了绘制方面的函数
6. hankaku:	 定义了字体
7. int:			 处理中断
8. dsctbl:	 处理内存分段表及中断定义
9. fifo：		 定义了一个先入先出的栈

#### 汇编与C语言的映射
- 内存写入(可直接利用指针来写入)：
		_write_mem8: 	;void write_mem8(int addr, int data);
			mov	ECX, [ESP+4] 	; [ESP+4] 中存放的是addr
			mov	AL , [ESP+8]	; [ESP+8] 中存放的是data
			mov	[ECX], AL
			RET
-	向设备写入数据(OUT:从CPU向外写):
		_io_out8:	;void io_out8(int port, int data);
			mov EDX, [ESP+4]
			mov AL , [ESP+8]
			OUT	DX, AL
			RET
		_io_out16:	;void io_out16(int port, int data);
			mov EDX, [ESP+4]
			mov EAX, [ESP+8]
			OUT DX, AX
			RET
		_io_out32:	;void io_out32(int port, int data);
			mov EDX, [ESP+4]
			mov	EAX, [ESP+8]
			mov	DX,	EAX
			RET
- 从设备读入数据(IN:从设备向CPU内读入):
		_io_in8:	int io_in8(int port)
			mov EDX, [ESP+4]
			mov	EAX, 0
			IN	AL, DX
			RET
- 屏蔽中断：
		_io_cli:	void io_cli(void);
			CLI
			RET
- 恢复中断:
		_io_sti:	void io_sti(void);
			STI
			RET_
			
####  指针
- 4个字节,32位
- 指针变量里面存储的是一个地址
- 指针声明时的类型是为了说明指针在某个地址存储时所需要多大的空间

#### C语言
- char ： 1 个字节
- 字符串是char的一个集合，以0x00结尾。
		
#### 函数
- 显示图形:
		void boxfill8(unsigned char *vram, int xsize, unsigned char c, int x0, int y0, int x1, int y1);
		//vram:表示开始的地址; xsize:屏幕的宽度; c: 颜色; (x0,y0):左上角的地址; (x1,y1):右下角的地址
		//对于任意的像素点(x,y),其地址为:xsize * y + x,
- 显示字体：
		void putfont8(char* vram, int size, int x, int y, char c, char *font);
		//vram:表示字体的起始地址; size:屏幕的宽度; (x,y):字体的左上角; c: 颜色; font:字体
		//每个字体在8*16的像素矩阵中表示，8位一个字节，即每个字体16个字节
		//每个像素点的位置: (y + i) * xsize + x + 0/1/2/3/4/5/6/7
- 显示变量
	利用sprintf()函数，将数值拷贝到变量中，然后输出该变量

#### 段与GDT
-	分段: 将内存划分为很多块，每一块的起始地址都看作0来处理,像这样分割出来的块，就称为段(segment) 
- 表示一个段时，段包含的信息(8个字节)：
	- 段的起始地址
	- 段的大小
	- 段的管理属性
- 段的寄存器只有16位，因为段寄存器低3位不可以使用，段寄存器只能处理0~8191即8192个段表。8192*8=64KB，
64KB数据称为GDT(global (segment) descriptor table 全局段号记录表)
- GDT: 数据存储在内存当中，内存的起始地址和有效设定个数存放在CPU内被称作GDTR的特殊寄存器(48位)中。低
16位(内存的最初2个字节)存储段的上限，表示量的大小，剩下的32位，代表着GDT的开始地址。

#### 中断与IDT
- CPU遇到外部状况变化，或者内部偶然发生某些错误时，会临时切换过去处理这种突发事件。这就是中断功能。
中断发生后，CPU暂时停止正在处理的任务，并做好接下来能够继续处理的准备，转而执行中断程序。中断程序执
行完毕以后，再调用事先设定好的函数，返回处理中的任务。
- IDT(interrupt descriptor table 中断记录表),使用中断需要初始化PIC。IDT记录了0-255的中断号码与调用函
数的对应关系,与GDT类似。中断表中记录着中断号与需要调用的函数的对应关系。
- PIC(programmable interrupt controller: 可编程中断控制器),CPU只能处理一个中断，于是就增加了芯片组来
处理多个中断,PIC是将8个中断信号集合成一个中断信号的装置。 
- 与CPU相连的PIC是主PIC，被称为PIC0。处理0-7号中断信号(IRQ),与主PIC2号(从0开始计数)相连的为从PIC，被
称为PIC1
- PIC内部有许多寄存器,它的初始化需要按照一定的规则。PIC的寄存器都是8位的。
	- IMR(interrupt mask register 中断屏蔽寄存器)8位对应8路IRQ信号，1表示该路信号被屏蔽,PIC忽视该路信
	号
	- ICW(initial control word: 初始化控制数据),PIC中有4个，对应编号1-4,共4个字节的数据。
		-	ICW1和ICW4与PIC主板配线方式、中断信号的电气特性有关。
		- ICW3是主从连接的设定，对主PIC而言，第几号IRQ与PIC相连，如果全是1,则8主PIC连接有8个从PIC
		- ICW2决定了IRQ以哪一号中断通知CPU
- 中断发生后CPU会命令PIC发送两个字节的数据，这两个字节数据就是一个指令，CPU无法区分这两个字节是来自
内存还是来自PIC，CPU会执行这个指令，这就产生了中断。产生的中断只能是0x20及以后,在PIC初始化时对ICW2的设
定决定着使用哪一号中断
- 鼠标是IRQ12,键盘是IRQ1。鼠标的中断指令为INT 0x2c，键盘的中断指令为INT 0x21。注意，鼠标是在从PIC上
- 中断发生后会调用对应的中断函数(naskfunc文件中定义了这些函数，其实就是保存寄存器中的东西),naskfunc
中的中断函数调用外部c语言写的中断处理函数(读取数据),最后函数返回，交给汇编恢复先前的状态。

#### 读取中断的数据
- 为了提高效率利用FIFO即先进先出的数据结构
		struct FIFO{
			char * buf; //	数据缓冲区
			int size; 	//	数据的大小
			int free;		//	数据空闲的大小
			int p;			// 	数据要写入的缓冲区下标
			int q; 			// 	数据要读出的缓冲区下标
		}

#### 鼠标中断
- 鼠标产生的中断数据是3个字节一组的，第一个字节的高4位，
