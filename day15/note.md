## Days15

#### 多任务
- 操作系统可以同时运行多个程序

#### 任务切换
- CPU切换任务时需要耗费一定的时间:0.0001秒左右
- 任务切换有一定的时间间隔，间隔太小，CPU切换任务消耗的时间所占程序运行时间的比例过大,
- 发出任务切换指令，CPU会把寄存器中的值全部写入内存，然后从内存中读取下一个程序的所有寄存器的值。

#### 任务相关的结构体
- 操作系统欧中存在任务状态段，简称TSS。有16位和32位两个版本
- TSS
	struct TSS32{
		int backlink, esp0, ss0, esp1, ss1, esp2,	ss2, cr3;	
		// 上面的变量是与任务设置相关的信息, 任务切换时不会被CPU写入
		int eip,	eflags,	eax,	ecx,	edx,	ebx,	esp,	ebp,	esi,	edi; // 32位寄存器
		int es,	cs,	ss,	ds,	fs,	gs;	//16位寄存器
		int ldtr,	iomap;	//任务设置的部分,任务切换时不会被CPU写入
	};
- eip: CPU用来记录下一条需要执行的指令位于内存中哪个地址的寄存器，即指令寄存器。
	- JMP指令实际上是一个向EIP寄存器赋值的指令，该指令篡改了CPU记忆中下一条该执行的指令的地址。但是不
	能直接使用汇编语言向该寄存器赋值。
	- 在TSS中将EIP寄存器的值记录下来，当下次再返回这个任务的时候，CPU就可以明白应该从哪里读取读取程序
- TR寄存器(task register):让CPU记住当前正在运行的任务。每次给TR寄存器赋值时，必须
把GDT的编号乘以8。


#### 任务切换的方法
- 使用JMP指令
如果一条JMP指令所指定的目标地址段不是可执行的代码，而是TSS的话，CPU就不会执行通常的改写EIP和CS的操作
，而是将这条指令理解为任务切换。也就是说，CPU会切换到目标TSS所指定的任务。
	- near模式
	- far模式：同时改写EIP与CS（代码段寄存器）,在JMP目标地址中带冒号(:)的，就是far模式的JMP指令
			JMP DWORD 2*8:0x0000001b
			// 将EIP存入0x1b的同时，将CS置为2*8(16)
- CPU每次执行带有段地址的指令时，都会确认一下GDT中的设置，以便判断接下来要执行的JMP指令到底是普通的
far-JMP，还是任务切换。即从汇编翻译出来的机器语言来看，普通的far-JMP和任务切换的far-JMP,指令本身是没
有任何区别的。

#### 关于汇编
- LTR: 改变TR寄存器的值，
- taskswitch4函数：里面JMP指令后跟着RET指令.含义:切换任务之后，再返回这个任务的时
候，程序会从JMP指令之后恢复运行，即RET，从汇编语言函数返回，继续运行C语言主程序。
	- far-JMP指令用作任务切换，地址段（冒号前面的部分）要指向TSS，偏移量（冒号后面的
	部分)并没有实际作用。
- JMP FAR [ESP + 4]: 执行far跳转，指定一个地址之后，会从该地址中读取4个字节的数据
，将其存入EIP寄存器中，再继续读取2个字节的数据，将其存入CS寄存器中。
		_farjmp:		void farjmp(int eip, int cs);
			JMP	FAR [ESP + 4]
			RET
		// 调用farjmp(eip,cs)函数之后，[ESP+4]位置存放了eip(执行下一条指令)的值，[ESP+8]的位置存放了cs的值
	
#### C与语言中两个进程之间传值
1. 将值写入一个固定的内存地址当中
2. 利用指定函数参数的方法，强行在函数的相应内存中指定一个参数,即指定函数栈中[ESP+4]
处的内容为参数内容，这样函数即认为已经传入新的参数

#### 函数RETURN的地址
- 函数return的时候返回的地址保存在栈中,地址是[ESP],向该地址写入合适的值即可告诉
CPU应该返回的地址

